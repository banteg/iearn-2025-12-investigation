{"compiler":{"version":"0.8.25+commit.b61c2a91"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"uint256","name":"baseRatePerYear_","type":"uint256"},{"internalType":"uint256","name":"multiplierPerYear_","type":"uint256"},{"internalType":"uint256","name":"jumpMultiplierPerYear_","type":"uint256"},{"internalType":"uint256","name":"kink_","type":"uint256"},{"internalType":"contract IAccessControlManagerV8","name":"accessControlManager_","type":"address"},{"internalType":"bool","name":"timeBased_","type":"bool"},{"internalType":"uint256","name":"blocksPerYear_","type":"uint256"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"InvalidBlocksPerYear","type":"error"},{"inputs":[],"name":"InvalidTimeBasedConfiguration","type":"error"},{"inputs":[{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"calledContract","type":"address"},{"internalType":"string","name":"methodSignature","type":"string"}],"name":"Unauthorized","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"baseRatePerBlockOrTimestamp","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"multiplierPerBlockOrTimestamp","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"jumpMultiplierPerBlockOrTimestamp","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"kink","type":"uint256"}],"name":"NewInterestParams","type":"event"},{"inputs":[],"name":"accessControlManager","outputs":[{"internalType":"contract IAccessControlManagerV8","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseRatePerBlock","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"blocksOrSecondsPerYear","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getBlockNumberOrTimestamp","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"cash","type":"uint256"},{"internalType":"uint256","name":"borrows","type":"uint256"},{"internalType":"uint256","name":"reserves","type":"uint256"},{"internalType":"uint256","name":"badDebt","type":"uint256"}],"name":"getBorrowRate","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"cash","type":"uint256"},{"internalType":"uint256","name":"borrows","type":"uint256"},{"internalType":"uint256","name":"reserves","type":"uint256"},{"internalType":"uint256","name":"reserveFactorMantissa","type":"uint256"},{"internalType":"uint256","name":"badDebt","type":"uint256"}],"name":"getSupplyRate","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"isInterestRateModel","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"isTimeBased","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"jumpMultiplierPerBlock","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"kink","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"multiplierPerBlock","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"baseRatePerYear","type":"uint256"},{"internalType":"uint256","name":"multiplierPerYear","type":"uint256"},{"internalType":"uint256","name":"jumpMultiplierPerYear","type":"uint256"},{"internalType":"uint256","name":"kink_","type":"uint256"}],"name":"updateJumpRateModel","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"cash","type":"uint256"},{"internalType":"uint256","name":"borrows","type":"uint256"},{"internalType":"uint256","name":"reserves","type":"uint256"},{"internalType":"uint256","name":"badDebt","type":"uint256"}],"name":"utilizationRate","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"}],"devdoc":{"author":"Compound (modified by Dharma Labs, Arr00 and Venus)","kind":"dev","methods":{"constructor":{"params":{"accessControlManager_":"The address of the AccessControlManager contract","baseRatePerYear_":"The approximate target base APR, as a mantissa (scaled by EXP_SCALE)","blocksPerYear_":"The number of blocks per year","jumpMultiplierPerYear_":"The multiplier after hitting a specified utilization point","kink_":"The utilization point at which the jump multiplier is applied","multiplierPerYear_":"The rate of increase in interest rate wrt utilization (scaled by EXP_SCALE)","timeBased_":"A boolean indicating whether the contract is based on time or block."}},"getBlockNumberOrTimestamp()":{"details":"Function to simply retrieve block number or block timestamp","returns":{"_0":"Current block number or block timestamp"}},"getBorrowRate(uint256,uint256,uint256,uint256)":{"params":{"badDebt":"The amount of badDebt in the market","borrows":"The amount of borrows in the market","cash":"The amount of cash in the market","reserves":"The amount of reserves in the market"},"returns":{"_0":"The borrow rate percentage per slot (block or second) as a mantissa (scaled by 1e18)"}},"getSupplyRate(uint256,uint256,uint256,uint256,uint256)":{"params":{"badDebt":"The amount of badDebt in the market","borrows":"The amount of borrows in the market","cash":"The amount of cash in the market","reserveFactorMantissa":"The current reserve factor for the market","reserves":"The amount of reserves in the market"},"returns":{"_0":"The supply rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)"}},"isInterestRateModel()":{"returns":{"_0":"Always true"}},"updateJumpRateModel(uint256,uint256,uint256,uint256)":{"custom:access":"Controlled by AccessControlManager","custom:error":"Unauthorized if the sender is not allowed to call this function","params":{"baseRatePerYear":"The approximate target base APR, as a mantissa (scaled by EXP_SCALE)","jumpMultiplierPerYear":"The multiplierPerBlockOrTimestamp after hitting a specified utilization point","kink_":"The utilization point at which the jump multiplier is applied","multiplierPerYear":"The rate of increase in interest rate wrt utilization (scaled by EXP_SCALE)"}},"utilizationRate(uint256,uint256,uint256,uint256)":{"params":{"badDebt":"The amount of badDebt in the market","borrows":"The amount of borrows in the market","cash":"The amount of cash in the market","reserves":"The amount of reserves in the market (currently unused)"},"returns":{"_0":"The utilization rate as a mantissa between [0, MANTISSA_ONE]"}}},"title":"JumpRateModelV2","version":1},"userdoc":{"errors":{"InvalidBlocksPerYear()":[{"notice":"Thrown when blocks per year is invalid"}],"InvalidTimeBasedConfiguration()":[{"notice":"Thrown when time based but blocks per year is provided"}],"Unauthorized(address,address,string)":[{"notice":"Thrown when the action is prohibited by AccessControlManager"}]},"kind":"user","methods":{"accessControlManager()":{"notice":"The address of the AccessControlManager contract"},"baseRatePerBlock()":{"notice":"The base interest rate per block or second which is the y-intercept when utilization rate is 0"},"blocksOrSecondsPerYear()":{"notice":"Stores blocksPerYear if isTimeBased is true else secondsPerYear is stored"},"constructor":{"notice":"Construct an interest rate model"},"getBorrowRate(uint256,uint256,uint256,uint256)":{"notice":"Calculates the current borrow rate per slot (block or second)"},"getSupplyRate(uint256,uint256,uint256,uint256,uint256)":{"notice":"Calculates the current supply rate per slot (block or second)"},"isInterestRateModel()":{"notice":"Indicator that this is an InterestRateModel contract (for inspection)"},"isTimeBased()":{"notice":"Acknowledges if a contract is time based or not"},"jumpMultiplierPerBlock()":{"notice":"The multiplier per block or second after hitting a specified utilization point"},"kink()":{"notice":"The utilization point at which the jump multiplier is applied"},"multiplierPerBlock()":{"notice":"The multiplier of utilization rate per block or second that gives the slope of the interest rate"},"updateJumpRateModel(uint256,uint256,uint256,uint256)":{"notice":"Update the parameters of the interest rate model"},"utilizationRate(uint256,uint256,uint256,uint256)":{"notice":"Calculates the utilization rate of the market: `(borrows + badDebt) / (cash + borrows + badDebt - reserves)`"}},"notice":"An interest rate model with a steep increase after a certain utilization threshold called **kink** is reached. The parameters of this interest rate model can be adjusted by the owner. Version 2 modifies Version 1 by enabling updateable parameters","version":1}},"settings":{"compilationTarget":{"contracts/JumpRateModelV2.sol":"JumpRateModelV2"},"evmVersion":"paris","libraries":{},"metadata":{"bytecodeHash":"ipfs","useLiteralContent":true},"optimizer":{"enabled":true,"runs":200},"remappings":[]},"sources":{"@openzeppelin/contracts/access/IAccessControl.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n","keccak256":"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57","license":"MIT"},"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IAccessControlManagerV8\n * @author Venus\n * @notice Interface implemented by the `AccessControlManagerV8` contract.\n */\ninterface IAccessControlManagerV8 is IAccessControl {\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\n\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) external;\n\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\n\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) external view returns (bool);\n}\n","keccak256":"0xaa29b098440d0b3a131c5ecdf25ce548790c1b5ac7bf9b5c0264b6af6f7a1e0b","license":"BSD-3-Clause"},"@venusprotocol/solidity-utilities/contracts/TimeManagerV8.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { SECONDS_PER_YEAR } from \"./constants.sol\";\n\nabstract contract TimeManagerV8 {\n    /// @notice Stores blocksPerYear if isTimeBased is true else secondsPerYear is stored\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    uint256 public immutable blocksOrSecondsPerYear;\n\n    /// @notice Acknowledges if a contract is time based or not\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    bool public immutable isTimeBased;\n\n    /// @notice Stores the current block timestamp or block number depending on isTimeBased\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\n    function() view returns (uint256) private immutable _getCurrentSlot;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n\n    /// @notice Thrown when blocks per year is invalid\n    error InvalidBlocksPerYear();\n\n    /// @notice Thrown when time based but blocks per year is provided\n    error InvalidTimeBasedConfiguration();\n\n    /**\n     * @param timeBased_ A boolean indicating whether the contract is based on time or block\n     * If timeBased is true than blocksPerYear_ param is ignored as blocksOrSecondsPerYear is set to SECONDS_PER_YEAR\n     * @param blocksPerYear_ The number of blocks per year\n     * @custom:error InvalidBlocksPerYear is thrown if blocksPerYear entered is zero and timeBased is false\n     * @custom:error InvalidTimeBasedConfiguration is thrown if blocksPerYear entered is non zero and timeBased is true\n     * @custom:oz-upgrades-unsafe-allow constructor\n     */\n    constructor(bool timeBased_, uint256 blocksPerYear_) {\n        if (!timeBased_ && blocksPerYear_ == 0) {\n            revert InvalidBlocksPerYear();\n        }\n\n        if (timeBased_ && blocksPerYear_ != 0) {\n            revert InvalidTimeBasedConfiguration();\n        }\n\n        isTimeBased = timeBased_;\n        blocksOrSecondsPerYear = timeBased_ ? SECONDS_PER_YEAR : blocksPerYear_;\n        _getCurrentSlot = timeBased_ ? _getBlockTimestamp : _getBlockNumber;\n    }\n\n    /**\n     * @dev Function to simply retrieve block number or block timestamp\n     * @return Current block number or block timestamp\n     */\n    function getBlockNumberOrTimestamp() public view virtual returns (uint256) {\n        return _getCurrentSlot();\n    }\n\n    /**\n     * @dev Returns the current timestamp in seconds\n     * @return The current timestamp\n     */\n    function _getBlockTimestamp() private view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /**\n     * @dev Returns the current block number\n     * @return The current block number\n     */\n    function _getBlockNumber() private view returns (uint256) {\n        return block.number;\n    }\n}\n","keccak256":"0x57a2bbb9b8e02b1c0a5c0e305fef1328a22db56c3d4b148c362010a6e767243c","license":"BSD-3-Clause"},"@venusprotocol/solidity-utilities/contracts/constants.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\nuint256 constant EXP_SCALE = 1e18;\n\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\nuint256 constant MANTISSA_ONE = EXP_SCALE;\n\n/// @dev The approximate number of seconds per year\nuint256 constant SECONDS_PER_YEAR = 31_536_000;\n","keccak256":"0x14de93ead464da249af31bea0e3bcfb62ec693bea3475fb4d90f055ac81dc5eb","license":"BSD-3-Clause"},"contracts/InterestRateModel.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/**\n * @title Compound's InterestRateModel Interface\n * @author Compound\n */\nabstract contract InterestRateModel {\n    /**\n     * @notice Calculates the current borrow interest rate per slot (block or second)\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param badDebt The amount of badDebt in the market\n     * @return The borrow rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 badDebt\n    ) external view virtual returns (uint256);\n\n    /**\n     * @notice Calculates the current supply interest rate per slot (block or second)\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @param badDebt The amount of badDebt in the market\n     * @return The supply rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa,\n        uint256 badDebt\n    ) external view virtual returns (uint256);\n\n    /**\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\n     * @return Always true\n     */\n    function isInterestRateModel() external pure virtual returns (bool) {\n        return true;\n    }\n}\n","keccak256":"0xc4fda1ab75ebe4b187b707c4f10c58780f343cf343c537f641dc75d3cd28ab51","license":"BSD-3-Clause"},"contracts/JumpRateModelV2.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { IAccessControlManagerV8 } from \"@venusprotocol/governance-contracts/contracts/Governance/IAccessControlManagerV8.sol\";\nimport { TimeManagerV8 } from \"@venusprotocol/solidity-utilities/contracts/TimeManagerV8.sol\";\nimport { InterestRateModel } from \"./InterestRateModel.sol\";\nimport { EXP_SCALE, MANTISSA_ONE } from \"./lib/constants.sol\";\n\n/**\n * @title JumpRateModelV2\n * @author Compound (modified by Dharma Labs, Arr00 and Venus)\n * @notice An interest rate model with a steep increase after a certain utilization threshold called **kink** is reached.\n * The parameters of this interest rate model can be adjusted by the owner. Version 2 modifies Version 1 by enabling updateable parameters\n */\ncontract JumpRateModelV2 is InterestRateModel, TimeManagerV8 {\n    /**\n     * @notice The address of the AccessControlManager contract\n     */\n    IAccessControlManagerV8 public accessControlManager;\n\n    /**\n     * @notice The multiplier of utilization rate per block or second that gives the slope of the interest rate\n     */\n    uint256 public multiplierPerBlock;\n\n    /**\n     * @notice The base interest rate per block or second which is the y-intercept when utilization rate is 0\n     */\n    uint256 public baseRatePerBlock;\n\n    /**\n     * @notice The multiplier per block or second after hitting a specified utilization point\n     */\n    uint256 public jumpMultiplierPerBlock;\n\n    /**\n     * @notice The utilization point at which the jump multiplier is applied\n     */\n    uint256 public kink;\n\n    event NewInterestParams(\n        uint256 baseRatePerBlockOrTimestamp,\n        uint256 multiplierPerBlockOrTimestamp,\n        uint256 jumpMultiplierPerBlockOrTimestamp,\n        uint256 kink\n    );\n\n    /**\n     * @notice Thrown when the action is prohibited by AccessControlManager\n     */\n    error Unauthorized(address sender, address calledContract, string methodSignature);\n\n    /**\n     * @notice Construct an interest rate model\n     * @param baseRatePerYear_ The approximate target base APR, as a mantissa (scaled by EXP_SCALE)\n     * @param multiplierPerYear_ The rate of increase in interest rate wrt utilization (scaled by EXP_SCALE)\n     * @param jumpMultiplierPerYear_ The multiplier after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param accessControlManager_ The address of the AccessControlManager contract\n     * @param timeBased_ A boolean indicating whether the contract is based on time or block.\n     * @param blocksPerYear_ The number of blocks per year\n     */\n    constructor(\n        uint256 baseRatePerYear_,\n        uint256 multiplierPerYear_,\n        uint256 jumpMultiplierPerYear_,\n        uint256 kink_,\n        IAccessControlManagerV8 accessControlManager_,\n        bool timeBased_,\n        uint256 blocksPerYear_\n    ) TimeManagerV8(timeBased_, blocksPerYear_) {\n        require(address(accessControlManager_) != address(0), \"invalid ACM address\");\n\n        accessControlManager = accessControlManager_;\n\n        _updateJumpRateModel(baseRatePerYear_, multiplierPerYear_, jumpMultiplierPerYear_, kink_);\n    }\n\n    /**\n     * @notice Update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by EXP_SCALE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by EXP_SCALE)\n     * @param jumpMultiplierPerYear The multiplierPerBlockOrTimestamp after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @custom:error Unauthorized if the sender is not allowed to call this function\n     * @custom:access Controlled by AccessControlManager\n     */\n    function updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) external virtual {\n        string memory signature = \"updateJumpRateModel(uint256,uint256,uint256,uint256)\";\n        bool isAllowedToCall = accessControlManager.isAllowedToCall(msg.sender, signature);\n\n        if (!isAllowedToCall) {\n            revert Unauthorized(msg.sender, address(this), signature);\n        }\n\n        _updateJumpRateModel(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per slot (block or second)\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param badDebt The amount of badDebt in the market\n     * @return The borrow rate percentage per slot (block or second) as a mantissa (scaled by 1e18)\n     */\n    function getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 badDebt\n    ) external view override returns (uint256) {\n        return _getBorrowRate(cash, borrows, reserves, badDebt);\n    }\n\n    /**\n     * @notice Calculates the current supply rate per slot (block or second)\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @param badDebt The amount of badDebt in the market\n     * @return The supply rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)\n     */\n    function getSupplyRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 reserveFactorMantissa,\n        uint256 badDebt\n    ) public view virtual override returns (uint256) {\n        uint256 oneMinusReserveFactor = MANTISSA_ONE - reserveFactorMantissa;\n        uint256 borrowRate = _getBorrowRate(cash, borrows, reserves, badDebt);\n        uint256 rateToPool = (borrowRate * oneMinusReserveFactor) / EXP_SCALE;\n        uint256 incomeToDistribute = borrows * rateToPool;\n        uint256 supply = cash + borrows + badDebt - reserves;\n        return incomeToDistribute / supply;\n    }\n\n    /**\n     * @notice Calculates the utilization rate of the market: `(borrows + badDebt) / (cash + borrows + badDebt - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @param badDebt The amount of badDebt in the market\n     * @return The utilization rate as a mantissa between [0, MANTISSA_ONE]\n     */\n    function utilizationRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 badDebt\n    ) public pure returns (uint256) {\n        // Utilization rate is 0 when there are no borrows and badDebt\n        if ((borrows + badDebt) == 0) {\n            return 0;\n        }\n\n        uint256 rate = ((borrows + badDebt) * EXP_SCALE) / (cash + borrows + badDebt - reserves);\n\n        if (rate > EXP_SCALE) {\n            rate = EXP_SCALE;\n        }\n\n        return rate;\n    }\n\n    /**\n     * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by EXP_SCALE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by EXP_SCALE)\n     * @param jumpMultiplierPerYear The multiplierPerBlockOrTimestamp after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n    function _updateJumpRateModel(\n        uint256 baseRatePerYear,\n        uint256 multiplierPerYear,\n        uint256 jumpMultiplierPerYear,\n        uint256 kink_\n    ) internal {\n        baseRatePerBlock = baseRatePerYear / blocksOrSecondsPerYear;\n        multiplierPerBlock = multiplierPerYear / blocksOrSecondsPerYear;\n        jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksOrSecondsPerYear;\n        kink = kink_;\n\n        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n    }\n\n    /**\n     * @notice Calculates the current borrow rate per slot (block or second), with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param badDebt The amount of badDebt in the market\n     * @return The borrow rate percentage per slot (block or second) as a mantissa (scaled by EXP_SCALE)\n     */\n    function _getBorrowRate(\n        uint256 cash,\n        uint256 borrows,\n        uint256 reserves,\n        uint256 badDebt\n    ) internal view returns (uint256) {\n        uint256 util = utilizationRate(cash, borrows, reserves, badDebt);\n        uint256 kink_ = kink;\n\n        if (util <= kink_) {\n            return ((util * multiplierPerBlock) / EXP_SCALE) + baseRatePerBlock;\n        }\n        uint256 normalRate = ((kink_ * multiplierPerBlock) / EXP_SCALE) + baseRatePerBlock;\n        uint256 excessUtil;\n        unchecked {\n            excessUtil = util - kink_;\n        }\n        return ((excessUtil * jumpMultiplierPerBlock) / EXP_SCALE) + normalRate;\n    }\n}\n","keccak256":"0x926821f88c135be782af42e894cbc733f2d565f720f7b473ac5f37836aace26f","license":"BSD-3-Clause"},"contracts/lib/constants.sol":{"content":"// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\n/// @dev The approximate number of seconds per year\nuint256 constant SECONDS_PER_YEAR = 31_536_000;\n\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\nuint256 constant EXP_SCALE = 1e18;\n\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\nuint256 constant MANTISSA_ONE = EXP_SCALE;\n","keccak256":"0x54ab3a6f3bc87569ed12370f3470a1ec84cea9796d4d0ccf3d07dd4280c044aa","license":"BSD-3-Clause"}},"version":1}